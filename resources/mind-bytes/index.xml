<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Mind bytes | Galactic Forensics Laboratory</title><link>https://galactic-forensics.space/resources/mind-bytes/</link><atom:link href="https://galactic-forensics.space/resources/mind-bytes/index.xml" rel="self" type="application/rss+xml"/><description>Mind bytes</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© (2022) · Galactic Forensics Laboratory · Brandeis University</copyright><image><url>https://galactic-forensics.space/images/logo_hueb41359ad733f2a4eb80221204fe0002_32021_300x300_fit_lanczos_2.png</url><title>Mind bytes</title><link>https://galactic-forensics.space/resources/mind-bytes/</link></image><item><title>The number of atoms in a SiC stardust grain</title><link>https://galactic-forensics.space/resources/mind-bytes/atoms_in_sic_grain/atoms_in_sic_grain/</link><pubDate>Sat, 26 Mar 2022 00:00:00 +0000</pubDate><guid>https://galactic-forensics.space/resources/mind-bytes/atoms_in_sic_grain/atoms_in_sic_grain/</guid><description>&lt;p>
&lt;a href="https://mybinder.org/v2/gh/galactic-forensics/website/HEAD?labpath=static%2Ffiles%2Fjupyter%2Fatoms_in_sic_grain.ipynb" target="_blank" rel="noopener">&lt;img src="https://mybinder.org/badge_logo.svg" alt="Binder">&lt;/a>&lt;/p>
&lt;p>In this article, we will analyze how many atoms of a given trace element are in a presolar SiC grain of a given size. Furthermore, the Jupyter notebook in which this article was written is available via
&lt;a href="https://mybinder.org/" target="_blank" rel="noopener">&lt;code>binder&lt;/code>&lt;/a>, so you can adjust it at any point to change the calculations and adopt it to your needs. Click on the icon on top to run this notebook in
&lt;a href="https://mybinder.org/" target="_blank" rel="noopener">&lt;code>binder&lt;/code>&lt;/a>. Throughout this notebook we will be using SI units.&lt;/p>
&lt;p>First, let us calculate the mass of a given SiC grain. We therefore need to define its radius \(r\) and it&amp;rsquo;s typical density \(\rho = 3160\,\)kg m\(^{-3}\) (according to
&lt;a href="https://en.wikipedia.org/wiki/Silicon_carbide" target="_blank" rel="noopener">Wikipedia&lt;/a>). Via the volume \(V\) for a spherical grain&lt;/p>
&lt;p>\begin{equation}
V = \frac{4}{3} \pi r^3,
\end{equation}&lt;/p>
&lt;p>we can calculate the mass of the grain as:&lt;/p>
&lt;p>\begin{equation}
m = V\rho = \frac{4}{3} \pi r^3 \rho
\end{equation}&lt;/p>
&lt;p>For a given radius, we can now write a &lt;code>python&lt;/code> function to calculate the mass as following:&lt;/p>
&lt;pre>&lt;code class="language-python">import math
rho = 3160 # kg / m**3
def mass(r: float) -&amp;gt; float:
&amp;quot;&amp;quot;&amp;quot;Calculate mass of spherical grain with density `rho`.
:param r: Radius in meters
:return: Mass in kg
&amp;quot;&amp;quot;&amp;quot;
return 4/3 * math.pi * r**3 * rho
&lt;/code>&lt;/pre>
&lt;p>The approximate molar mass of SiC is the molar mass of a silicon atom plus the molar mass of a carbon atom, therefore \(M_\mathrm{SiC} = 40\,\)g mol\(^{-1}\). Let us assume we have some trace element, e.g., iron, given at a concentration of 10 ppm. If the concentration is by weight \(c_{wt}\), we can directly calculate the mass of all the iron as:&lt;/p>
&lt;p>\begin{equation}
m_\mathrm{Fe} = c_{wt} \times m
\end{equation}&lt;/p>
&lt;p>If the concentration is given by number of atoms \(c_n\), we first have to convert it first in order to calculate the mass of iron of the grain. For this, we need to know the molar mass of iron, which is approximately \(M_\mathrm{Fe} = 56\,\)g mol\(^{-1}\). The mass of iron can in this case be calculated as:&lt;/p>
&lt;p>\begin{equation}
m_\mathrm{Fe} = c_n \frac{M_\mathrm{Fe}}{M_\mathrm{SiC}} \times m
\end{equation}&lt;/p>
&lt;p>Let us now calculate the mass of the species of interest with &lt;code>python&lt;/code>:&lt;/p>
&lt;pre>&lt;code class="language-python">molar_mass_sic = 40 * 1e-3 # kg / mol
# calculate mass of a species of interest
def mass_species(r: float, mol_mass: float, conc: float, conc_as_weight: bool) -&amp;gt; float:
&amp;quot;&amp;quot;&amp;quot;Calculate mass of the given species in a SiC grain.
:param r: Radius of the SiC grain in m.
:param mol_mass: Molar mass of the species of interest in kg / mol.
:param conc: Concentration of the species of interest.
:param conc_as_weight: Is the concentration per weight (`True`) or by number (`False`).
:return: Mass of species in kg
&amp;quot;&amp;quot;&amp;quot;
cwt = conc if conc_as_weight else conc * mol_mass / molar_mass_sic
mass_species = cwt * mass(r)
return mass_species
&lt;/code>&lt;/pre>
&lt;p>Finally, we know that per mol of material, Avogadro&amp;rsquo;s number \(N_A = 6.0221415 \times 10^{23}\) of atoms are present. For iron, we could therefore calculate the number of atoms as:&lt;/p>
&lt;p>\begin{equation}
n_\mathrm{Fe} = N_A \frac{m_\mathrm{Fe}}{M_\mathrm{Fe}}
\end{equation}&lt;/p>
&lt;p>Here, \(M_\mathrm{Fe}\) is again the molar mass of iron. We can now create our final function in &lt;code>python&lt;/code>:&lt;/p>
&lt;pre>&lt;code class="language-python">n_a = 6.0221415e23
def number_of_atoms(r: float, mol_mass: float, conc: float, conc_as_weight: bool) -&amp;gt; float:
&amp;quot;&amp;quot;&amp;quot;Calculate the number of atoms for a given species in a presolar SiC grain.
:param r: Radius of the SiC grain.
:param mol_mass: Molar mass of the species of interest in kg / mol.
:param conc: Concentration of the species of interest.
:param conc_as_weight: Is the concentration per weight (`True`) or by number (`False`).
:return: Mass of species in kg
&amp;quot;&amp;quot;&amp;quot;
m_species = mass_species(r, mol_mass, conc, conc_as_weight)
n_species = n_a * m_species / mol_mass
return n_species
&lt;/code>&lt;/pre>
&lt;p>We can now run some examples using the everything we just created.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong> Assume we have 10 ppm by weight of iron in a grain with 1 µm radius. We can then calculate the number of atoms as:&lt;/p>
&lt;pre>&lt;code class="language-python">r = 1e-6
mol_mass = 56e-3
conc = 10e-6
conc_as_weight = True
n_fe = number_of_atoms(r, mol_mass, conc, conc_as_weight)
print(f&amp;quot;Number of iron atoms per grain: {n_fe:.3e}&amp;quot;)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>Number of iron atoms per grain: 1.423e+06
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Example 2:&lt;/strong> We can perform the same calculation, assuming that the concentration is per number. Since the molar mass of iron is heavier than the molar mass of SiC, we would expect the total number of atoms to be larger than in example 1. Let&amp;rsquo;s see if that is true:&lt;/p>
&lt;pre>&lt;code class="language-python">n_fe = number_of_atoms(r, mol_mass, conc, False)
print(f&amp;quot;Number of iron atoms per grain: {n_fe:.3e}&amp;quot;)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>Number of iron atoms per grain: 1.993e+06
&lt;/code>&lt;/pre>
&lt;p>This simple Jupyter Notebook allows you to determine how many atoms of a species you would expect in a SiC stardust grain. If you then want to measure the atoms, you&amp;rsquo;ll know what you&amp;rsquo;re up against. Good luck!&lt;/p></description></item><item><title>Resources for Programming</title><link>https://galactic-forensics.space/resources/mind-bytes/resources_programming/</link><pubDate>Tue, 25 Jan 2022 00:00:00 +0000</pubDate><guid>https://galactic-forensics.space/resources/mind-bytes/resources_programming/</guid><description>&lt;p>Sooner or later, most scientist have to automate certain tasks.
It is generally advisable to leave such repetitive things that can be
automated to the computer. Here we have a look at tools that might help with
this task.&lt;/p>
&lt;p>First things first: this is by no means going to be a comprehensive article,
but will rather be my own, fairly biased view, which heavily focuses on
&lt;a href="https://www.python.org/" target="_blank" rel="noopener">&lt;code>python&lt;/code>&lt;/a> and
&lt;a href="https://git-scm.com/" target="_blank" rel="noopener">&lt;code>git&lt;/code>&lt;/a>.
It hopefully starts simple, and then gets more advanced fast.&lt;/p>
&lt;h2 id="python">Python&lt;/h2>
&lt;p>Python is a scripted computer language that allows you to do many scientific
tasks, e.g., data evaluation, automatically. It is a fairly simple language to
learn, and you can get going fast, however, be open to learn more advanced
techniques later on. This means: Never stop learning! Python has many advanced
capabilities that can make your life easier and faster.&lt;/p>
&lt;h3 id="learning-python">Learning Python&lt;/h3>
&lt;p>
&lt;a href="https://software-carpentry.org/lessons/" target="_blank" rel="noopener">Software Carpentry&lt;/a> has two great
lessons on &lt;code>python&lt;/code>, which are especially suited for beginners. These lessons
should give you an introduction and overview of the language, but also teach
you how to plot figures using &lt;code>matplotlib&lt;/code>.&lt;/p>
&lt;p>A great book to introduce you python was written by Allen Downy and can
be found
&lt;a href="https://greenteapress.com/wp/think-python-2e/" target="_blank" rel="noopener">here&lt;/a>. It is available
for free. The book gives an in-depth introduction into &lt;code>python&lt;/code>, but also into
the basics behind the language. Such knowledge is always helpful later on,
since it gives you a deeper understanding of certain behavior.&lt;/p>
&lt;h3 id="working-with-python">Working with Python&lt;/h3>
&lt;p>The official &lt;code>python&lt;/code> distribution is distributed from
&lt;a href="https://www.python.org" target="_blank" rel="noopener">python.org&lt;/a>.
If you install this distribution, you can add further packages using
&lt;a href="https://pip.pypa.io/en/stable/" target="_blank" rel="noopener">&lt;code>pip&lt;/code>&lt;/a>.
However, this is not always the most straight forward way to work with &lt;code>python&lt;/code>.&lt;/p>
&lt;h4 id="virtual-environments">Virtual environments&lt;/h4>
&lt;p>Virtual environments should be considered for all your projects. Depending
on what &lt;code>python&lt;/code> environment you are using, these environments will be
created different. It is worth looking into it.&lt;/p>
&lt;h4 id="anaconda">Anaconda&lt;/h4>
&lt;p>For data processing and scientific python, check out
&lt;a href="https://www.anaconda.com/products/individual" target="_blank" rel="noopener">Anaconda&lt;/a>. This gives you a
&lt;code>conda&lt;/code> environment for &lt;code>python&lt;/code>. Furthermore, Anaconda comes with many
packages pre-installed and has a graphical manager to handle your distribution.
This can be advantageous, depending on what you need.&lt;/p>
&lt;h4 id="pyenv">&lt;code>pyenv&lt;/code>&lt;/h4>
&lt;p>If you need to handle multiple different python versions and want
to easily manage virtual environments, check out
&lt;a href="https://github.com/pyenv/pyenv" target="_blank" rel="noopener">&lt;code>pyenv&lt;/code>&lt;/a>.&lt;/p>
&lt;h4 id="jupyter">Jupyter&lt;/h4>
&lt;p>Finally, Jupyter Notebooks give a straight forward interface
to &lt;code>python&lt;/code> that allow you to play and develop code in a browser, as well as
to document it in
&lt;a href="https://www.markdownguide.org/" target="_blank" rel="noopener">Markdown&lt;/a>.
Googles flavor of Jupyter is called
&lt;a href="https://colab.research.google.com/" target="_blank" rel="noopener">Google Collab&lt;/a> and run on the web.
JetBrains, the creator of PyCharm, also has an online Jupyter Notebook
Server with is especially great for developing at the same time. It is
called
&lt;a href="https://datalore.jetbrains.com/" target="_blank" rel="noopener">Datalore&lt;/a>.&lt;/p>
&lt;p>For Astrophysics, especially if you are interested in
&lt;a href="https://nugrid.github.io/" target="_blank" rel="noopener">NuGrid&lt;/a> data, check out the
&lt;a href="https://astrohub.uvic.ca/" target="_blank" rel="noopener">Astrohub&lt;/a>. You can log into the public outreach
server with your GitHub account and then use a JupyterLab environment to run
your astrophysics models.&lt;/p>
&lt;h4 id="editors">Editors&lt;/h4>
&lt;p>Many good python editors exist. Personally, I prefer
&lt;a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">PyCharm&lt;/a>, however, many other options.
PyCharm is a fully integrated developer environment (IDE) and comes with many
more tools than you need in the beginning, it can therefore be overwhelming at
first.&lt;/p>
&lt;p>Other notable editors are
&lt;a href="https://www.spyder-ide.org/" target="_blank" rel="noopener">Spyder&lt;/a>, which is a full
IDE that comes pre-installed with Anaconda. Also notable is
&lt;a href="https://www.sublimetext.com/" target="_blank" rel="noopener">Sublime Text&lt;/a>, which works in my workflow
especially well for scripting.
&lt;a href="https://www.tabnine.com/blog/python-on-sublime-text/" target="_blank" rel="noopener">Here&lt;/a>
is a great article on how to set up Sublime Text for python.&lt;/p>
&lt;h3 id="guis">GUIs&lt;/h3>
&lt;p>If you are interested in creating graphical user interfaces for your programs,
it is worth looking into GUIs. Two potential GUI creation packages that you
might want to consider using are
&lt;a href="https://www.riverbankcomputing.com/software/pyqt/intro/" target="_blank" rel="noopener">&lt;code>PyQt&lt;/code>&lt;/a> or
&lt;a href="https://wiki.qt.io/PySide2" target="_blank" rel="noopener">&lt;code>PySide&lt;/code>&lt;/a>.
Great tutorials on Qt can be found
&lt;a href="https://www.pythonguis.com/pyqt5-tutorial/" target="_blank" rel="noopener">here&lt;/a>.&lt;/p>
&lt;p>If you want to package your GUIs with installers,
check out
&lt;a href="https://build-system.fman.io/" target="_blank" rel="noopener">&lt;code>fbs&lt;/code>&lt;/a>. Note that the open / free
version only supports &lt;code>python-3.6&lt;/code> and is restricted to &lt;code>PyQt5&lt;/code>. If you want
to dabble with the pro version, let me know.&lt;/p>
&lt;h3 id="advanced-python">Advanced Python&lt;/h3>
&lt;h4 id="auto-formatting">Auto-formatting&lt;/h4>
&lt;p>Formatting &lt;code>python&lt;/code> code should adhere - for readability - to certain rules.
These are often also referred as linting requirements. While it is tedious to
format code by hand, automatic formatters are very helpful. I generally use
&lt;a href="https://github.com/psf/black" target="_blank" rel="noopener">&lt;code>black&lt;/code>&lt;/a> to format my &lt;code>python&lt;/code> code.
The beauty of this is that it there are not many possibilities to format your
code, therefore, most of the decisions are already made, and it always looks
awesome. Various plugins exist that can be used in editors and IDEs.
&lt;a href="https://www.duckduckgo.com" target="_blank" rel="noopener">Search engines&lt;/a> are useful to find them.&lt;/p>
&lt;h4 id="test-your-code">Test your code!&lt;/h4>
&lt;p>Testing of code is crucial, since you generally want to make sure that your
scripts, functions, classes, etc., do what you want them to do.
An amazing package to test your python code is
&lt;a href="https://docs.pytest.org/en/6.2.x/" target="_blank" rel="noopener">&lt;code>pytest&lt;/code>&lt;/a>. If you are interested in
learning testing with python, check out Brian Okken&amp;rsquo;s book
&lt;a href="https://pythontest.com/pytest-book/" target="_blank" rel="noopener">here&lt;/a>.&lt;/p>
&lt;h2 id="git">Git&lt;/h2>
&lt;p>When working with code, version control should be an integral part of your
workflow. One way of controlling versions is with &lt;code>git&lt;/code>.
The Galactic Forensics Laboratory has its &lt;code>git&lt;/code> repositories hosted
&lt;a href="https://github.com/galactic-forensics" target="_blank" rel="noopener">here on GitHub&lt;/a>. Lab members get
access to all repositories of the lab.&lt;/p>
&lt;h3 id="learning-git">Learning &lt;code>git&lt;/code>&lt;/h3>
&lt;p>The best way to learn &lt;code>git&lt;/code> and / or to review your skill is by going through
&lt;a href="https://swcarpentry.github.io/git-novice/" target="_blank" rel="noopener">this course on Software Carpentry&lt;/a>.
The next step is then to use &lt;code>git&lt;/code> and, if you want to keep your repos online,
a service such as
&lt;a href="https://github.com" target="_blank" rel="noopener">GitHub&lt;/a>. You can also browse the &lt;code>git&lt;/code>
book, which is available for free
&lt;a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">here&lt;/a>.&lt;/p>
&lt;p>The beauty of &lt;code>git&lt;/code> is that you can most of the time go back in time if you
made a mistake. So don&amp;rsquo;t worry if something happens! A good resource for
these weird cases is
&lt;a href="https://dangitgit.com/" target="_blank" rel="noopener">Dangit Git&lt;/a>.&lt;/p>
&lt;h3 id="good-practices">Good practices&lt;/h3>
&lt;p>If you want to contribute code to a repository of which you are not a
maintainer, you should fork the repository to your own GitHub account.
Then create a branch with an appropriate name for the feature you want to
contribute. Add your changes, push your branch to your fork, and then create
a pull request where you describe what you have changed and why. Keep it short,
but descriptive.&lt;/p>
&lt;p>Most projects, e.g., the
&lt;a href="https://github.com/galactic-forensics/iniabu" target="_blank" rel="noopener">&lt;code>iniabu&lt;/code>&lt;/a>
project have a developers guide that gives you additional information on
how to contribute. For &lt;code>iniabu&lt;/code>, you can find the guide, e.g.,
&lt;a href="https://iniabu.readthedocs.io/en/latest/dev/index.html" target="_blank" rel="noopener">here in the docs&lt;/a>.&lt;/p>
&lt;h3 id="advanced-git-and-github">Advanced &lt;code>git&lt;/code> and GitHub&lt;/h3>
&lt;h4 id="pre-commit">&lt;code>pre-commit&lt;/code>&lt;/h4>
&lt;p>If you are using &lt;code>git&lt;/code> regularly, especially on public projects, &lt;code>pre-commit&lt;/code>
can help you to automate tasks. You can install so-called &lt;code>hooks&lt;/code> that help
you perform various tasks, e.g., formatting, etc. Check out the
&lt;a href="https://pre-commit.com/" target="_blank" rel="noopener">&lt;code>pre-commit&lt;/code> website&lt;/a>.&lt;/p>
&lt;h4 id="github-actions">GitHub Actions&lt;/h4>
&lt;p>For automatic testing on GitHub, consider using
&lt;a href="https://github.com/features/actions" target="_blank" rel="noopener">GitHub Actions&lt;/a>. These actions can
especially help when using continuous integration (CI).&lt;/p>
&lt;h2 id="some-more-advanced-resources">Some more advanced resources&lt;/h2>
&lt;h3 id="code-coverage">Code coverage&lt;/h3>
&lt;p>When testing your python code, it is useful to know how many lines of your
code are actually tested by your test suite. To automate this process,
you can, e.g., use GitHub hooks for
&lt;a href="https://coveralls.io/" target="_blank" rel="noopener">&lt;code>coveralls&lt;/code>&lt;/a>.&lt;/p>
&lt;h3 id="documentation">Documentation&lt;/h3>
&lt;p>Last, but surely not least, you will likely make extensive use of great
documentations that you can find online. For &lt;code>python&lt;/code> code, automatic
documentation using your doc strings can be really helpful. One tool to do so
is
&lt;a href="https://www.sphinx-doc.org/en/master/" target="_blank" rel="noopener">&lt;code>sphinx&lt;/code>&lt;/a>.
This is especially powerful in combination with
&lt;a href="https://readthedocs.org/" target="_blank" rel="noopener">ReadTheDocs&lt;/a>, which can also be implemented with
a GitHub hook.&lt;/p>
&lt;h3 id="hypermodern-python">Hypermodern Python&lt;/h3>
&lt;p>Finally, if you want to code in &lt;code>python&lt;/code> using many bells and whistles,
check out the blog articles on hypermodern python by Claudio Jolowicz.
The series can be found
&lt;a href="https://cjolowicz.github.io/posts/" target="_blank" rel="noopener">here&lt;/a>, the
first article
&lt;a href="https://cjolowicz.github.io/posts/hypermodern-python-01-setup/" target="_blank" rel="noopener">here&lt;/a>.&lt;/p></description></item></channel></rss>